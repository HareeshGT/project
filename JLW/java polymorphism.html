<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>java polymorphism</title>
    <link rel="stylesheet" href="object.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

</head>

<body>
    <header class="navigation-bar">
        <nav class="nav">
            <div class="container">
              <h1 class="logo"><a href="#">Java Learner</a></h1>
              <img src="images\logo.png" alt="logo">
              <ul>
                <li><a href="index.html"><i class="fa-solid fa-house"></i> Home</a></li>
                <li><a href="text.html"><i class="fa-solid fa-book"></i> Text Content</a></li>
                <li><a href="videos.html"><i class="fa-solid fa-play"></i> Video Tutorial</a></li>
                <li><a href="practice code.html"><i class="fa-solid fa-terminal"></i> Practice Problems</a></li>
                <li><a href="./Compiler Java/index.php"><i class="fa-solid fa-gears" style=" color: #108a00;"></i> Compiler</a></li>
              </ul>
            </div>
          </nav>
</header>
<section class="">
    <div class="wrapper">
        <input type="checkbox" id="btn" hidden>
        <label for="btn" class="menu-btn">
          <i class="fas fa-bars"></i>
          <i class="fas fa-times"></i>
        </label>
        <nav id="sidebar">
          <div class="title">Side Menu</div>
          <ul class="list-items">
            <li><a href="java basics.html">Java Basics</a></li>
            <li><a href="ControlStatements.html">Control Statements</a></li>
            <li><a href="java array.html">Java Array</a></li>
            <li><a href="java strings.html">Java String</a></li>
            <li><a href="java string methods.html">Java String Methods</a></li>
            <li><a href="java object class.html">Java Object Class</a></li>
            <li><a href="java inheritance.html">Java Inheritance</a></li>
            <li><a href="java polymorphism.html">Java Polymorphism</a></li>
            <li><a href="abstraction.html">Java Abstraction</a></li>
            <li><a href="encapsulation.html">Java Encapsulation</a></li>
        </ul>
        </nav>
      </div>
</section>

    <section class="obcontent">
        <br>
        <!--polymorphism-->
        <div>   
            <h1 class="heading-1">Polymorphism in Object-Oriented Programming (OOP)</h1>
        
            <h2 class="heading-2">Polymorphism:</h2>
            
            <p>
                <strong>Definition:</strong> Polymorphism is a fundamental concept in OOP that allows objects of different types to be treated as objects of a common type. It enables a single interface to represent multiple types, providing flexibility, extensibility, and improved code organization.
            </p>
        <br>
            <h2 class="heading-2">Types of Polymorphism:</h2> <br>
        
            <h3 class="heading-3">1. Compile-time Polymorphism (Method Overloading):</h3>
        
            <p>
                <strong>Definition:</strong> Method overloading allows a class to have multiple methods with the same name but different parameters.
            </p>
        
            <p>
                <strong>Key Points:</strong>
            </p>
            <div class="space">
            <ul>
                <li>The compiler determines which method to call based on the number or types of arguments during compile-time.</li>
                <li>It provides a way to define multiple versions of a method to handle different parameter sets.</li>
            </ul>
            </div>
            <p>
                <strong>Example:</strong>
            </p>
        
            <pre>
                <code>
        public class MathOperations {
            public int add(int a, int b) {
                return a + b;
            }
        
            public double add(double a, double b) {
                return a + b;
            }
        }
                </code>
            </pre>
        
            <h3 class="heading-3">2. Runtime Polymorphism (Method Overriding):</h3>
        
            <p>
                <strong>Definition:</strong> Method overriding allows a subclass to provide a specific implementation of a method that is already defined in its superclass.
            </p>
        
            <p>
                <strong>Key Points:</strong>
            </p>
            <div class="space">
            <ul>
                <li>The decision of which method to call is made dynamically during runtime.</li>
                <li>It enables the subclass to provide its own implementation of a method, promoting flexibility and customization.</li>
            </ul>
        </div>
            <p>
                <strong>Example:</strong>
            </p>
        
            <pre>
                <code>
        class Animal {
            public void sound() {
                System.out.println("Animal makes a sound");
            }
        }
        
        class Dog extends Animal {
            public void sound() {
                System.out.println("Dog barks");
            }
        }
                </code>
            </pre>
        
            <h2 class="heading-2">General Explanation:</h2>
        
            <p>
                <strong>Common Interface:</strong> Polymorphism allows objects of different classes to be treated through a common interface, promoting code reusability and flexibility. A single method or interface can be used to interact with various types of objects, simplifying code and reducing redundancy.
            </p>
        
            <p>
                <strong>Abstraction:</strong> Polymorphism contributes to abstraction by hiding the specific implementation details of objects and focusing on their common interface. It allows developers to work with high-level abstractions, making code more readable and maintainable.
            </p>
        
            <p>
                <strong>Adaptability:</strong> Polymorphism makes code more adaptable to changes. New classes can be added without modifying existing code, as long as they adhere to the common interface.
            </p>
        
            <p>
                <strong>Dynamic Binding:</strong> Runtime polymorphism involves dynamic binding, where the decision of which method to call is made at runtime based on the actual type of the object.
            </p>
        
            <p>
                <strong>Code Readability:</strong> Polymorphism improves code readability by allowing developers to write code that works with generic types, making it easier to understand and maintain.
            </p>
        </div>
        <br>
        <hr>
        
        <!--Benefits of Polymorphism in Java-->
        <div>
        
            <h1 class="heading-1">Benefits of Polymorphism in Java</h1>
        
            <h2 class="heading-2">1. Code Reusability:</h2>
            <p>
                <strong>Explanation:</strong> Polymorphism allows different classes to be treated through a common interface, promoting the reuse of code for methods that operate on objects with that common interface or superclass.
            </p>
            <pre>
                <code>
        interface Shape {
            void draw();
        }
        
        class Circle implements Shape {
            public void draw() {
                System.out.println("Drawing a circle");
            }
        }
        
        class Square implements Shape {
            public void draw() {
                System.out.println("Drawing a square");
            }
        }
        </code>
            </pre>
        
            <h2 class="heading-2">2. Flexibility and Extensibility:</h2>
            <p>
                <strong>Explanation:</strong> New classes can be added to the system without modifying existing code, as long as they adhere to the common interface or inherit from a common superclass. This promotes flexibility and extensibility.
            </p>
            <pre>
                <code>
        interface Animal {
            void makeSound();
        }
        
        class Dog implements Animal {
            public void makeSound() {
                System.out.println("Dog barks");
            }
        }
        
        class Cat implements Animal {
            public void makeSound() {
                System.out.println("Cat meows");
            }
        }
        </code>
            </pre>
        
            <h2 class="heading-2">3. Enhanced Readability:</h2>
            <p>
                <strong>Explanation:</strong> Polymorphism allows developers to work with high-level abstractions, making the code more readable and understandable. Code becomes more expressive and focused on the essential functionalities.
            </p>
            <pre>
                <code>
        void performOperation(Operation operation) {
            operation.execute();
        }
        
        // Usage
        performOperation(new AdditionOperation());
        performOperation(new SubtractionOperation());
        </code>
            </pre>
        
            <h2 class="heading-2">4. Simplified Code Maintenance:</h2>
            <p>
                <strong>Explanation:</strong> Polymorphism simplifies code maintenance by reducing the interdependencies between classes. Changes to one part of the code are less likely to affect other parts, leading to a more modular and maintainable codebase.
            </p>
            <pre>
                <code>
        interface Printer {
            void print();
        }
        
        class LaserPrinter implements Printer {
            public void print() {
                System.out.println("Printing with a laser printer");
            }
        }
        
        class InkjetPrinter implements Printer {
            public void print() {
                // Log to a file
            }
        }
        </code>
            </pre>
        
            <h2 class="heading-2">5. Dynamic Method Binding:</h2>
            <p>
                <strong>Explanation:</strong> Runtime polymorphism involves dynamic method binding, where the decision of which method to call is made at runtime based on the actual type of the object. This enhances flexibility during execution.
            </p>
            <pre>
                <code>
        Animal animal = new Dog();
        animal.makeSound(); // Calls the sound() method of the Dog class at runtime
        </code>
            </pre>
        
            <h2 class="heading-2">6. Reduced Code Redundancy:</h2>
            <p>
                <strong>Explanation:</strong> Polymorphism reduces code redundancy by allowing the use of a common interface for different types of objects. This leads to cleaner and more concise code.
            </p>
            <pre>
                <code>
        interface Logger {
            void log(String message);
        }
        
        class ConsoleLogger implements Logger {
            public void log(String message) {
                System.out.println("Console: " + message);
            }
        }
        
        class FileLogger implements Logger {
            public void log(String message) {
                // Log to a file
            }
        }
        </code>
            </pre>
        
            <h2 class="heading-2">7. Adaptability to Changes:</h2>
            <p>
                <strong>Explanation:</strong> Polymorphism makes code more adaptable to changes in requirements. New subclasses can be introduced without affecting existing code, supporting a more agile and responsive development process.
            </p>
            <pre>
                <code>
        interface PaymentMethod {
            void processPayment(double amount);
        }
        
        class CreditCard implements PaymentMethod {
            public void processPayment(double amount) {
                // Process credit card payment
            }
        }
        
        class PayPal implements PaymentMethod {
            public void processPayment(double amount) {
                // Process PayPal payment
            }
        }
        </code>
            </pre>
        
            <h2 class="heading-2">8. Easier Implementation of Frameworks and Libraries:</h2>
            <p>
                <strong>Explanation:</strong> Polymorphism is often leveraged in the implementation of frameworks and libraries, allowing developers to design APIs that work with a variety of objects. This makes it easier for other developers to use and extend these frameworks.
            </p>
            <pre>
                <code>
        // Part of a GUI framework
        interface UIComponent {
            void render();
        }
        
        class Button implements UIComponent {
            public void render() {
                // Render button
            }
        }
        
        class TextBox implements UIComponent {
            public void render() {
                // Render text box
            }
        }
        </code>
            </pre>
        
            <h2 class="heading-2">9. Promotion of Abstraction:</h2>
            <p>
                <strong>Explanation:</strong> Polymorphism promotes abstraction by allowing developers to work with high-level concepts and ignore the specific details of implementations. This leads to a clearer separation of concerns.
            </p>
            <pre>
                <code>
        interface Worker {
            void performWork();
        }
        
        class Engineer implements Worker {
            public void performWork() {
                // Engineer-specific work
            }
        }
        
        class Manager implements Worker {
            public void performWork() {
                // Manager-specific work
            }
        }
        </code>
            </pre>
        
            <h2 class="heading-2">10. Support for Open-Closed Principle:</h2>
            <p>
                <strong>Explanation:</strong> Polymorphism aligns with the Open-Closed Principle, stating that a class should be open for extension but closed for modification. New classes can be added without altering existing code, promoting a more maintainable and scalable design.
            </p>
            <pre>
                <code>
        interface Shape {
            void draw();
        }
        
        class Circle implements Shape {
            public void draw() {
                // Draw a circle
            }
        }
        
        class Rectangle implements Shape {
            public void draw() {
                // Draw a rectangle
            }
        }
        </code>
            </pre>
        
        </div>
        <br>
        <hr>
        <!--examples-->
        <div>
            
            <h1 class="heading-1">Polymorphism Problems</h1>
        
            <h2 class="heading-2">Problem 1: Shape Hierarchy with Polymorphic Rendering</h2>
        
            <p>This problem involves creating a hierarchy of shapes and implementing a polymorphic rendering mechanism using Java.</p>
        <br>
            <!-- Shape Hierarchy -->
            <h3 class="heading-3">Shape Hierarchy:</h3>
            <pre>
                <code>
        abstract class Shape {
            abstract void draw();
        }
        
        class Circle extends Shape {
            void draw() {
                System.out.println("Drawing a circle");
            }
        }
        
        class Rectangle extends Shape {
            void draw() {
                System.out.println("Drawing a rectangle");
            }
        }
        
        class Triangle extends Shape {
            void draw() {
                System.out.println("Drawing a triangle");
            }
        }
        </code>
            </pre>
        
            <!-- Shape Renderer -->
            <h3 class="heading-3">Shape Renderer:</h3>
            <pre>
                <code>
        class ShapeRenderer {
            void renderShape(Shape shape) {
                shape.draw();
            }
        }
        </code>
            </pre>
        
        
            <h2 class="heading-2">Problem 2: Banking System with Polymorphic Transactions</h2>
        
            <p>This problem involves implementing a basic banking system with polymorphic transaction processing using Java.</p>
        <br>
            <!-- Account Class -->
            <h3 class="heading-3">Account Class:</h3>
            <pre>
                <code>
        class Account {
            private double balance;
        
            public Account(double balance) {
                this.balance = balance;
            }
        
            public double getBalance() {
                return balance;
            }
        
            public void deposit(double amount) {
                balance += amount;
                System.out.println("Deposited: " + amount);
            }
        
            public void withdraw(double amount) {
                if (amount <= balance) {
                    balance -= amount;
                    System.out.println("Withdrawn: " + amount);
                } else {
                    System.out.println("Insufficient funds");
                }
            }
        }
        </code>
            </pre>
            <!-- TransactionProcessor Class -->
            <h3 class="heading-3">TransactionProcessor Class:</h3>
            <pre>
                <code>
        class TransactionProcessor {
            void processTransaction(Account account, Transaction transaction) {
                transaction.execute(account);
            }
        }
        </code>
            </pre>
        
            <!-- Transaction Interface -->
            <h3 class="heading-3">Transaction Interface:</h3>
            <pre>
                <code>
        interface Transaction {
            void execute(Account account);
        }
        </code>
            </pre>
        
            <!-- DepositTransaction Class -->
            <h3 class="heading-3">DepositTransaction Class:</h3>
            <pre>
                <code>
        class DepositTransaction implements Transaction {
            private double amount;
        
            public DepositTransaction(double amount) {
                this.amount = amount;
            }
        
            public void execute(Account account) {
                account.deposit(amount);
            }
        }
        </code>
            </pre>
        
            <!-- WithdrawTransaction Class -->
            <h3 class="heading-3">WithdrawTransaction Class:</h3>
            <pre>
                <code>
        class WithdrawTransaction implements Transaction {
            private double amount;
        
            public WithdrawTransaction(double amount) {
                this.amount = amount;
            }
        
            public void execute(Account account) {
                account.withdraw(amount);
            }
        }
        </code>
            </pre>
        </div>        
    </section>
</body>

</html>